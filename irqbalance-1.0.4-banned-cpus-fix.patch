diff -up irqbalance-1.0.4/cputree.c.orig irqbalance-1.0.4/cputree.c
--- irqbalance-1.0.4/cputree.c.orig	2014-01-14 16:34:32.280429819 +0100
+++ irqbalance-1.0.4/cputree.c	2014-01-14 16:35:16.166513993 +0100
@@ -55,7 +55,7 @@ cpumask_t cpu_possible_map;
    it's convenient to have the complement of banned_cpus available so that 
    the AND operator can be used to mask out unwanted cpus
 */
-static cpumask_t unbanned_cpus;
+cpumask_t unbanned_cpus;
 
 static struct topo_obj* add_cache_domain_to_package(struct topo_obj *cache, 
 						    cpumask_t package_mask)
diff -up irqbalance-1.0.4/irqbalance.h.orig irqbalance-1.0.4/irqbalance.h
--- irqbalance-1.0.4/irqbalance.h.orig	2014-01-14 16:34:46.200456549 +0100
+++ irqbalance-1.0.4/irqbalance.h	2014-01-14 16:36:26.246673191 +0100
@@ -69,6 +69,8 @@ extern enum hp_e hint_policy;
 extern unsigned long long cycle_count;
 extern unsigned long power_thresh;
 extern char *banscript;
+extern cpumask_t banned_cpus;
+extern cpumask_t unbanned_cpus;
 
 /*
  * Numa node access routines
diff -up irqbalance-1.0.4/placement.c.orig irqbalance-1.0.4/placement.c
--- irqbalance-1.0.4/placement.c.orig	2014-01-14 16:31:40.169095929 +0100
+++ irqbalance-1.0.4/placement.c	2014-01-14 16:32:41.434215607 +0100
@@ -53,6 +53,14 @@ static void find_best_object(struct topo
 		return;
 
 	/*
+	 * also don't consider any node that doesn't have at least one cpu in
+	 * the unbanned list
+	 */
+	if ((d->obj_type == OBJ_TYPE_NODE) &&
+	    (!cpus_intersects(d->mask, unbanned_cpus)))
+		return;
+
+	/*
  	 * If the hint policy is subset, then we only want 
  	 * to consider objects that are within the irqs hint, but
  	 * only if that irq in fact has published a hint
@@ -139,11 +147,17 @@ static void place_irq_in_node(struct irq
 	struct obj_placement place;
 	struct topo_obj *asign;
 
-	if( info->level == BALANCE_NONE)
+	if ((info->level == BALANCE_NONE) && cpus_empty(banned_cpus))
 		return;
 
 	if (irq_numa_node(info)->number != -1) {
 		/*
+		 * Need to make sure this node is elligible for migration
+		 * given the banned cpu list
+		 */
+		if (!cpus_intersects(irq_numa_node(info)->mask, unbanned_cpus))
+			goto find_placement;
+		/*
  		 * This irq belongs to a device with a preferred numa node
  		 * put it on that node
  		 */
@@ -153,6 +167,7 @@ static void place_irq_in_node(struct irq
 		return;
 	}
 
+find_placement:
 	place.best_cost = INT_MAX;
 	place.best = NULL;
 	place.least_irqs = NULL;
